# Это база

### Конвейер обработки запроса и middleware

Обработка запроса в ASP.NET Core устроена по принципу конвейера. Сначала данные запроса получает первый компонент в конвейере. После обработки он передает данные HTTP-запроса второму компоненту и так далее. Эти компоненты конвейера, которые отвечают за обработку запроса, называются middleware. 
Компоненты middleware конфигурируются с помощью методов расширений Run, Map и Use объекта IApplicationBuilder, который передается в метод Configure() класса Startup

![]()

Все вызовы типа app.UseXXX как раз и представляют собой добавление компонентов middleware для обработки запроса.

### Жизненный цикл middleware

Метод Configure выполняется один раз при создании объекта класса Startup, и компоненты middleware создаются один раз и живут в течение всего жизненного цикла приложения. То есть для последующей обработки запросов используются одни и те же компоненты.

![]()

### Методы Use, Run

Для конфигурации конвейера обработки запроса применяются методы Run, Map и Use.

**Run**

Метод Run представляет собой простейший способ для добавления компонентов middleware в конвейер. Однако компоненты, определенные через метод Run, не вызывают никакие другие компоненты и дальше обработку запроса не передают. Причем, так как данный метод не передает обработку запроса далее по конвейеру, то его следует помещать в самом конце.

**Use**

Метод Use в качестве параметров принимает контекст запроса - объект HttpContext и делегат Func<Task>, который представляет собой ссылку на следующий в конвейере компонент middleware.
Метод app.Use реализует простейшую задачу - умножение двух чисел и затем передает обработку запроса следующим компонентам middleware в конвейере.
То есть при вызове await next.Invoke() обработка запроса перейдет к тому компоненту, который установлен в методе app.Run()

![]()

При использовании метода Use и передаче выполнения следующему делегату следует учитывать, что не рекомендуется вызывать метод next.Invoke после метода Response.WriteAsync(). Как и то, что только один компонент middleware должен отправлять ответ клиенту. Он должен либо генерировать ответ с помощью Response.WriteAsync, либо вызывать следующий делегат посредством next.Invoke, но не выполнять оба этих действия одновременно (может поломаться протокол и могут придти лишние байты, что то не туда запишется и тд).

**ПЛОХОЙ КОД**

![]()

### Методы Map и MapWhen

**Map**

Метод Map применяется для сопоставления пути запроса с определенным делегатом-обработчиком. Все, что не будет обработано этими методами, пролетит в блок app.Run, который находится в конце метода Configure.

![]()

Также у метода Map могут быть под-маршруты. Таким образом:

![]()

Переходя по адресу /home, мы также можем перейти по его вложенным адресам /index и /about.

**MapWhen**

Метод принимает в качестве параметров функцию, принимающая в себя HttpContext и возвращающая bool и делегат, который выполнится, если результатом функции было true.

![]()

Выглядеть верный запрос должен следующим образом

![]()

<u>Стоит также учесть, что методы Run, Map и MapWhen являются конечными в конвейере, т.е. дальше себя они не могут "протолкнуть" запрос для обработки.</u>

### Создание компонентов middleware

За место методов Map, Use, Run мы можем использовать нами созданный компонент middleware и использовать его для обработки, вызвав в конфигурационном методе UseMiddleware(). Для этого нужно создать класс, конструктор которого будет принимать RequestDelegate, а также будет иметь метод Invoke, либо InvokeAsync, возвращающие новую задачу Task и принимающие HttpConext.

![]()

`app.UseMiddliware<AuthorizationMiddliware>();`

И мы можем вынести использование авторизации в метод расширения для интерфейса IApplicationBuilder.

![]()

Наш конфигурационный метод выглядит следующим образом

![]()

### Конвейер обработки запроса

Как правило, для обработки запроса применяется не один, а несколько компонентов middleware. И в этом случае большую роль может играть порядок их помещения в конвейер обработки запроса, а также то, как они взаимодействуют с другими компонентами.
Кроме того, каждый компонент middleware может обрабатывать запрос до и после последующих в конвейере компонентов. Данное обстоятельство позволяет предыдущим компонентам корректировать результат обработки последующих компонентов. (см. 4[Repeat]ConveyotOfRequestProcessing).

![Конвейер]()

### IWebHostEnvironment и окружение

Для взаимодействия со средой, в которой запущено приложение, применяются объекты, реализующие интерфейс IHostingEnvironment. Производные классы от данного интерфейса позволяют взаимодействовать со средой разработки (например, получать имя проекта, состояния: в разработке/продакшене или же указывать свои состояния). Примеры можно найти в проекте [5.IWebHostEnvironmentAndOther]().

### Static files

Статические файлы в проекте asp net хрянятся в папке wwwroot, которая не создается по умолчанию в Empty проекте. Тут все просто.
Так же мы можем использовать статические страницы как стандартные, т.е. находясь на http://localhost:xxxx/ ему будет высвечиваться страница по умолчанию. Для этого нужно создать в папке wwwroot файл с названием: default.htm(l) / index.htm(l). В случае, когда файл по умолчанию имеет уникальное имя, то его нужно указать в следующем коде:

![]()

### Метод UseDirectoryBrowser

С помощью этого метода можно реализовать стандартную навигацию в вывод клиенту всех файлов из директории со статик файлами

![]()

![]()

### Обработка ошибок

Имеется возможность обрабатывать ошибки в двух случаях: когда приложение в стадии разработки и когда работает в режиме прожакшена. Из этих двух статусов вытекает способ обработки исключений.
Если приложение находится в разработке, то при возникновении исключения на экране высвечивается максимально подробная информация об ошибке: где зачем и как. Выглядит это следующим образом (на примере деления на ноль):

![]()

Для того, чтобы включить обработку ошибок в режиме разработчика, код в Startup должен содержать следующее:

```C#
if(env.IsDevelopment()) // (конструкция if не обязательна)
{
	app.UseDeveloperExceptionPage();
}
```

Но в продакшене использовать такой стыд непозволительно, и для этого воспользуемся методом из следующего пункта.

### UseExceptionHandler

Чтобы по-своему обработать ошибку, можно воспользоваться методом UseExceptionHandler и в параметре указать путь, по которому будет вызван делегат-обработчик. Обработчиком, в данном примере, будет являться делегат метода **Map**. 

![]()

Теперь код выглядит таким образом.

### Обработка ошибок Http

В отличие от исключений стандартный функционал проекта ASP.NET Core почти никак не обрабатывает ошибки HTTP, например, в случае если ресурс не найден. При обращении к несуществующему ресурсу мы увидим в браузере пустую страницу, и только через консоль веб-браузера мы сможем увидеть статусный код. Но с помощью компонента StatusCodePagesMiddleware можно добавить в проект отправку информации о статусном коде. Для этого добавим в метод Configure() класса Startup вызов app.UseStatusCodePages().

Пишем это:

![]()

Обработчик выдает это:

![]()

Но также мы можем использовать и следующий код для обработки ошибок Http:

![]()

Первым параметром указывается MIME-тип (опр: Медиа тип, является стандартом, который описывает природу и формат документа, файла или набора байтов), а вторым - текст ошибки. В сообщение мы можем передать код ошибки через placeholder"{0}".
И, как не странно, мы увидим это:

![]()

А еще можно использовать такой обработчик

` pp.UseStatusCodePagesRedirects("/error/?code={0}");`

Но лучше такой:

![]()

В этом методе, первым параметром передается путь перенаправления, а вторым - параметры строки.

### Сервисы и Dependency Injection

**Dependency Injection (DI)** - это механизм, позволяющий сделать объекты в приложении слабосвязанными через абстракции, интерфейсы, что позволяет сделать систему гибкой и расширяемой.
Часто для внедрения зависимостей используются эдаке IoC контейнеры
(Inversion of Control). В ASP.NET 4 и раньше приходилось использовать внешние контейнеры (Ninject, Autofac, Unity, Windsor Castle, StructureMap), но в ASP.NET Core появился стандартный IoC контейнер - **IServiceProvider**, представляющий из себя интерфейс. А сами контейнеры стали называться **сервисами**. В итоге получается, что контейнеры это **провайдеры сервисов**. 
Для просмотра всех сервисов можно воспользоваться объектов **IServiceCollection**. 

### Информация о сервисах

Описание сервиса предосталвяет объект ServiceDescriptor.
Важными его свойствами являются:
**ServiceType** - тип сервиса
**ImplementationType** - тип реализации сервиса
**Lifetime** - жизненный цикл

### Создание собственных сервисов

Чтобы создавать собственные сервисы, нам необходимо лишь создать обобщающий интерфейс и реализующие его классы. После чего добавить эти сервисы в методе **ConfigureServices**, используя параметр типа **IServiceCollection** и его метод **AddTransient**. 

![]()

Не стоит забывать указать наш сервис в параметре метода **Configure**. После всех манипуляций мы можем использовать свой собственный сервис.
А еще можно воспользоваться методом расширения, чтобы можно было удобнее внедрять свой сервис через метод расширения для интерфейса **IServiceCollection**.

![]()

### Передача зависимостей

Из пункта выше можно понять, что передавать сервисы можно в метод Sturtup, но вопрос: можно ли то же самое сделать и со своими классами? Использовать сервисы там, где захочется. И ответ очевиден: да (пи=да).
Для передачи сервисом можно воспользоваться следующими методами:

* через конструктор класса

* через параметр метода Configure
* через параметр метода Invoke компонента Middleware
* через св-во RequestServices контекста запроса HttpContext в middleware
* через св-во ApplicationServices объекта IApllicationBuilder в классе Startup

С параметром метода Configure все понятно, идем дальше.
Создадим свой класс, использующий сервис IHomeBuilder и поимеем такую структуру:

![]()

А также напишем такой код, чтобы передать в конструктор класса HomeBuilderService сервис.

![]()

![]()

В данном случае мы подключаем в методе ConfigureService класс HomeBuilderService, так как этот класс использует непосредственно сервисы. Ну и магией asp net все это дело само создается и чудом передается, инициализируется, короче тупа В-А-У, рэально, честно, не обманываю.
Вот еше один крутой способ передачи использования и передачи сервисов.

### HttpContext.RequestServices

HttpContext.RequestServices предоставляет доступ ко всем внедренным зависимостям в методе **ConfigureServices**.

![]()

И если не будет найден сервис, тогда вылетит исключение (**StupidProgrammerMoment**).
Кста, еще, эта реализация является реализацией паттерна **Service locator**, который не рекомендуется использовать, однако это продолжают делать.

### ApplicationServices

Этот способ очень поход на предыдущий, но выполняется с помощью объекта **IApplicationBuilder**.

![]()

### Метод Invoke/InvokeAsync компонентов middleware

Ну и конечно же, самое главное место, где мы можем использовать сервисы - это middleware. Используем следующий код:

![]()

![]()

### Жизненный цикл зависимостей

Короче будем круты и будем сами указывать какой сервис как будет существовать и вообще...
Короче бывает *3 гендера жизненных циклов*:
**Transient** - временный, т.е. при каждом запросе создается новый объект сервиса. Во время одного запроса может быть множественное обращение к сервису, но каждый раз будет создаваться новый объект.
**Scoped** - ограниченный, т.е. при обработке одного запроса будет храниться и использоваться один объект сервиса.
**Singelton** - ну получается, что на протяжении всего срока существования приложения будет использоваться один объект.
Чтобы указывать в конфигурационном методе кто и сколько должен жить, нужно воспользоваться методами Add(Lifetime)< service ... >();

![]()

![]()

![]()